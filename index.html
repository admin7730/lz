<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ - åŠ¨æ€èƒŒæ™¯</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; /* é»˜è®¤é»‘è‰²èƒŒæ™¯ */
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        
        /* æ‘„åƒå¤´ç”»é¢å®¹å™¨ - ä½äºåº•å±‚, å……æ»¡å±å¹• */
        .video_container {
            position: absolute;
            inset: 0;
            z-index: 0; 
            display: none; /* é»˜è®¤éšè—, é€šè¿‡ JS åˆ‡æ¢æ˜¾ç¤º */
        }
        .input_video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* ç¡®ä¿ç”»é¢å……æ»¡å®¹å™¨ */
            transform: scaleX(-1); /* é•œåƒç¿»è½¬æ‘„åƒå¤´ç”»é¢ */
        }

        /* 3D Canvas å®¹å™¨ - ä½äºä¸­å±‚, èƒŒæ™¯é€æ˜ */
        #canvas-container {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        /* æ¶²æ€æ¯›ç»ç’ƒ UI */
        .glass-panel {
            /* æ›´æŸ”å’Œçš„èƒŒæ™¯, åŠé€æ˜ç™½è‰²å¸¦ä¸€ç‚¹è“è‰² */
            background: rgba(45, 45, 60, 0.7); 
            /* å¢å¼ºæ¨¡ç³Šåº¦ */
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            /* æŸ”å’Œçš„è¾¹æ¡†å’Œé˜´å½± */
            border: 1px solid rgba(170, 180, 255, 0.2);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 50px rgba(100, 150, 255, 0.2);
        }

        /* æŒ‰é’®æ ·å¼ä¿æŒ */
        .btn-interactive {
            transition: all 0.2s;
            border-radius: 0.75rem;
            border: 1px solid transparent;
        }
        .btn-interactive:hover {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
            border-color: #3b82f6;
        }
        
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- æ‘„åƒå¤´è¾“å…¥å®¹å™¨ (æ–°çš„èƒŒæ™¯å±‚) -->
    <div id="video-container" class="video_container">
        <video class="input_video"></video>
    </div>

    <!-- è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡å®¹å™¨ -->
    <div id="image-background" class="absolute inset-0 z-0 bg-cover bg-center" style="display: none;"></div>

    <!-- 3D å®¹å™¨ (ä½äºè§†é¢‘ä¸Šæ–¹, åŒ…å«ç²’å­) -->
    <div id="canvas-container"></div>

    <!-- UI æ§åˆ¶é¢æ¿ -->
    <div class="absolute top-4 right-4 z-20 w-80 glass-panel rounded-2xl p-6 text-white">
        <div class="flex items-center justify-between mb-5">
            <h1 class="text-2xl font-extrabold tracking-wider bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-indigo-400">
                âœ¨ æ¶²æ€ç²’å­æ§åˆ¶å°
            </h1>
            <div id="status-indicator" class="w-4 h-4 rounded-full bg-red-500 shadow-[0_0_12px_red]"></div>
        </div>

        <!-- åŠ è½½çŠ¶æ€ -->
        <div id="loading-msg" class="flex items-center space-x-3 text-sm text-gray-400 mb-6 p-2 bg-black/30 rounded-lg">
            <div class="loader"></div>
            <span>æ­£åœ¨å¯åŠ¨ AI æ¨¡å‹, è¯·ç¨å€™...</span>
        </div>

        <!-- äº¤äº’çŠ¶æ€å¡ç‰‡ -->
        <div class="space-y-3 mb-6">
            <div class="bg-gray-800/60 p-3 rounded-xl border border-gray-700/50">
                <div class="flex justify-between text-sm text-gray-300">
                    <span class="font-semibold">å®æ—¶æ‰‹åŠ¿:</span>
                    <span id="gesture-state" class="text-yellow-300 font-bold">ç­‰å¾…æ‰‹éƒ¨</span>
                </div>
            </div>
            
            <div class="bg-gray-800/60 p-3 rounded-xl border border-gray-700/50 text-xs">
                <div class="flex justify-between">
                    <span class="text-gray-400">å½“å‰èƒŒæ™¯:</span>
                    <span id="bg-mode-name" class="text-blue-300 font-mono font-bold">æ‘„åƒå¤´</span>
                </div>
                <!-- ä¿®å¤: æ·»åŠ  color-name å…ƒç´ , è§£å†³ TypeError -->
                <div class="flex justify-between mt-1">
                    <span class="text-gray-400">å½“å‰é¢œè‰²:</span>
                    <span id="color-name" class="text-purple-300 font-mono">Ocean Blue</span>
                </div>
                <!-- ä¿®å¤ç»“æŸ -->
                <div class="flex justify-between mt-1">
                    <span class="text-gray-400">å½“å‰å½¢çŠ¶:</span>
                    <span id="shape-name" class="text-green-300 font-mono">Heart</span>
                </div>
                <div class="flex justify-between mt-1">
                    <span class="text-gray-400">æ—‹è½¬é”å®š:</span>
                    <span id="lock-state" class="text-red-400 font-mono">æœªé”å®š</span>
                </div>
            </div>
        </div>
        
        <!-- æ–°å¢: ç²’å­å½¢çŠ¶é€‰æ‹© -->
        <div class="p-4 bg-gray-800/50 rounded-xl border border-gray-700/50 mb-6">
            <h3 class="text-sm font-semibold text-gray-300 mb-3">ğŸ’ ç²’å­å½¢çŠ¶é€‰æ‹© (é¼ æ ‡/è§¦æ‘¸)</h3>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="setShapeByName('heart')" class="btn-interactive p-2 text-xs bg-red-600/30 hover:bg-red-600/50">
                    â¤ï¸ å¿ƒå½¢
                </button>
                <button onclick="setShapeByName('sphere')" class="btn-interactive p-2 text-xs bg-yellow-600/30 hover:bg-yellow-600/50">
                    ğŸŒ çƒä½“
                </button>
                <button onclick="setShapeByName('saturn')" class="btn-interactive p-2 text-xs bg-purple-600/30 hover:bg-purple-600/50">
                    ğŸª åœŸæ˜Ÿ
                </button>
                <button onclick="setShapeByName('flower')" class="btn-interactive p-2 text-xs bg-pink-600/30 hover:bg-pink-600/50">
                    ğŸŒ¸ èŠ±å½¢
                </button>
                <button onclick="setShapeByName('buddha')" class="btn-interactive p-2 text-xs bg-lime-600/30 hover:bg-lime-600/50">
                    ğŸ§˜ ä½›é™€
                </button>
                <button onclick="setShapeByName('fireworks')" class="btn-interactive p-2 text-xs bg-sky-600/30 hover:bg-sky-600/50">
                    ğŸ† çƒŸèŠ±
                </button>
            </div>
        </div>
        
        <!-- èƒŒæ™¯åˆ‡æ¢æ§åˆ¶ -->
        <div class="p-4 bg-gray-800/50 rounded-xl border border-gray-700/50 mb-6">
            <h3 class="text-sm font-semibold text-gray-300 mb-3">ğŸŒŒ èƒŒæ™¯æ¨¡å¼åˆ‡æ¢</h3>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="setBackgroundMode('camera')" class="btn-interactive p-2 text-xs bg-teal-600/30 hover:bg-teal-600/50">
                    ğŸ¥ æ‘„åƒå¤´
                </button>
                <button onclick="setBackgroundMode('black')" class="btn-interactive p-2 text-xs bg-gray-600/30 hover:bg-gray-600/50">
                    âš« çº¯é»‘èƒŒæ™¯
                </button>
                <label class="btn-interactive p-2 text-xs bg-indigo-600/30 hover:bg-indigo-600/50 text-center cursor-pointer">
                    ğŸ–¼ï¸ ä¸Šä¼ å›¾ç‰‡
                    <input type="file" id="image-upload" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                </label>
            </div>
        </div>

        <!-- äº¤äº’æŒ‡å— -->
        <div class="p-4 bg-blue-900/40 rounded-xl border border-blue-700/50">
            <h3 class="text-sm font-semibold text-blue-300 mb-3">ğŸŒŸ ç²¾ç¡®æ‰‹åŠ¿æŒ‡å—</h3>
            <ul class="text-xs text-gray-300 list-disc list-inside space-y-1">
                <li>**ğŸ–ï¸ å¼ å¼€/æ¡æ‹³:** æ§åˆ¶æ‰©æ•£/å‡èš (é«˜çµæ•åº¦)ã€‚</li>
                <li>**ğŸ‘‰+ğŸ¤ æåˆ (é£ŸæŒ‡):** åˆ‡æ¢é¢œè‰²è°ƒè‰²æ¿ã€‚</li>
                <li>**ğŸ–•+ğŸ¤ æåˆ (ä¸­æŒ‡):** åˆ‡æ¢ç²’å­å½¢çŠ¶ã€‚</li>
                <li>**âœŒï¸ V å­—æ‰‹åŠ¿:** å¿«é€Ÿ**é‡ç½®**è§†è§’ã€‚</li>
                <li>**ğŸ‘Œ O ç¯æ‰‹åŠ¿:** **é”å®š/è§£é”**æ—‹è½¬ã€‚</li>
                <li>**â†”ï¸ æ‰‹éƒ¨ç§»åŠ¨:** æ—‹è½¬å’Œè°ƒæ•´ Z è½´æ·±åº¦ã€‚</li>
            </ul>
        </div>
    </div>

    <!-- å¼•å¯¼è¦†ç›–å±‚ -->
    <div id="overlay-guide" class="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/90 transition-opacity duration-1000">
        <h2 class="text-4xl font-extrabold text-white mb-4">è¯·å°†æ‰‹ç½®äºæ‘„åƒå¤´å‰</h2>
        <p class="text-lg text-blue-400">ç­‰å¾… AI æ¨¡å‹åˆå§‹åŒ–, ç„¶åå°è¯• V å­—æ‰‹åŠ¿ âœŒï¸</p>
    </div>

<script>
/**
 * æ ¸å¿ƒé…ç½®ä¸æ•°æ®
 */
const CONFIG = {
    particleCount: 20000,
    baseSize: 0.15,
    cameraZ: 60,
    pinchThreshold: 0.05, 
};

// ç¡®ä¿ SHAPES æ•°ç»„ä¸ HTML æŒ‰é’®çš„å‚æ•°ä¸€è‡´
const SHAPES = ['heart', 'sphere', 'saturn', 'flower', 'buddha', 'fireworks'];
let currentShapeIndex = 0;

const COLOR_PALETTES = [
    { name: "Ocean Blue", baseColor: 0x00aaff, variance: 0.2 },
    { name: "Neon Pink", baseColor: 0xff00ff, variance: 0.2 },
    { name: "Solar Flare", baseColor: 0xffcc00, variance: 0.3 },
    { name: "Deep Forest", baseColor: 0x00cc00, variance: 0.2 },
    { name: "Rainbow Burst", baseColor: 0xffffff, variance: 0.8 },
];
let currentColorIndex = 0;

// å…¨å±€å˜é‡
let scene, camera, renderer;
let particleSystem;
let targetPositions = []; 
let clock = new THREE.Clock();
let particleColors = new Float32Array(CONFIG.particleCount * 3); 
let isRotationLocked = false;
let backgroundMode = 'camera'; // åˆå§‹æ¨¡å¼ä¸º 'camera'

let handInteraction = {
    detected: false,
    openness: 0, 
    scale: 1,
    centerX: 0.5, 
    centerY: 0.5,
    centerZ: 0.5,
    pinchIndex: false, 
    pinchMiddle: false,
    isVsign: false, 
    isOKsign: false, 
    lastPinchIndexTime: 0,
    lastPinchMiddleTime: 0,
    lastVsignTime: 0,
    lastOKsignTime: 0,
};

/**
 * Three.js åœºæ™¯åˆå§‹åŒ–
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    // ç§»é™¤å›ºå®šçš„é›¾æ•ˆ, ä»¥ä¾¿é€‚åº”åŠ¨æ€èƒŒæ™¯

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = CONFIG.cameraZ;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    // å…³é”®: èƒŒæ™¯è®¾ç½®ä¸ºé€æ˜, ä»¥ä¾¿çœ‹åˆ°åº•å±‚çš„è§†é¢‘æˆ–å›¾ç‰‡
    renderer.setClearColor(0x000000, 0); 
    container.appendChild(renderer.domElement);

    createParticles();
    // ç¡®ä¿åœ¨åˆå§‹åŒ–æ—¶è®¾ç½®æ­£ç¡®çš„å½¢çŠ¶ç´¢å¼•
    const initialShape = SHAPES[currentShapeIndex];
    generateShape(initialShape);
    applyCurrentColorPalette();

    updateBackground(backgroundMode); // åˆå§‹è®¾ç½®èƒŒæ™¯ä¸ºæ‘„åƒå¤´

    window.addEventListener('resize', onWindowResize, false);
    animate();
}

/**
 * ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ (ä¸åŸç‰ˆç›¸åŒ, ç•¥å»é‡å¤ä»£ç )
 */
function createParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åˆå§‹éšæœºåˆ†å¸ƒ
        const r = 50 * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

    const material = new THREE.PointsMaterial({
        size: CONFIG.baseSize,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
}

// åŠ¨æ€é¢œè‰²åº”ç”¨: æ ¹æ® Z è½´æ·±åº¦ç”Ÿæˆæ¸å˜
function applyCurrentColorPalette() {
    const palette = COLOR_PALETTES[currentColorIndex];
    const baseColor = new THREE.Color(palette.baseColor);
    const colors = particleSystem.geometry.attributes.color.array;
    
    let minZ = Infinity, maxZ = -Infinity;
    for (let i = 2; i < targetPositions.length; i += 3) {
        if (targetPositions[i] < minZ) minZ = targetPositions[i];
        if (targetPositions[i] > maxZ) maxZ = targetPositions[i];
    }
    const rangeZ = maxZ - minZ + 0.001;

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const idx = i * 3;
        
        const normalizedZ = (targetPositions[idx + 2] - minZ) / rangeZ; 
        const t = normalizedZ; 
        
        const mixedColor = new THREE.Color();
        if (palette.baseColor === 0xffffff) {
            mixedColor.setHSL(t * 0.8 + Math.random() * 0.1, 1.0, 0.6);
        } else {
            const randomVariance = (Math.random() - 0.5) * palette.variance;
            mixedColor.setRGB(
                baseColor.r * (1 - t * 0.3) + randomVariance,
                baseColor.g * (1 - t * 0.3) + randomVariance,
                baseColor.b * (1 - t * 0.3) + randomVariance
            );
        }

        colors[idx] = mixedColor.r;
        colors[idx + 1] = mixedColor.g;
        colors[idx + 2] = mixedColor.b;
        
        particleColors[idx] = mixedColor.r;
        particleColors[idx + 1] = mixedColor.g;
        particleColors[idx + 2] = mixedColor.b;
    }
    
    particleSystem.geometry.attributes.color.needsUpdate = true;
    
    // ä¿®å¤: ç¡®ä¿ color-name å…ƒç´ å­˜åœ¨
    const colorNameElement = document.getElementById('color-name');
    if (colorNameElement) {
        colorNameElement.innerText = COLOR_PALETTES[currentColorIndex].name;
    } else {
        console.error("UI Error: 'color-name' element not found.");
    }
}

// å½¢çŠ¶ç”Ÿæˆç®—æ³• 
function generateShape(type) {
    const newPositions = new Float32Array(CONFIG.particleCount * 3);
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
        let x, y, z;
        const idx = i * 3;

        // --- å½¢çŠ¶ç”Ÿæˆé€»è¾‘ ---
        if (type === 'heart') {
            const t = Math.random() * Math.PI * 2;
            const r = 1 + Math.random() * 0.5;
            x = r * 16 * Math.pow(Math.sin(t), 3) * 1.2;
            y = r * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * 1.2 + 5;
            z = (Math.random() - 0.5) * 10;
        } else if (type === 'sphere') {
            const r = 20 * Math.cbrt(Math.random()); 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
        } else if (type === 'saturn') {
            const rand = Math.random();
            if (rand < 0.6) {
                const r = 10 * Math.cbrt(Math.random()); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else {
                const r = 14 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                x = r * Math.cos(theta);
                z = r * Math.sin(theta);
                y = (Math.random() - 0.5) * 1; 
                const tilt = Math.PI / 6;
                const _x = x;
                const _y = y * Math.cos(tilt) - z * Math.sin(tilt);
                const _z = y * Math.sin(tilt) + z * Math.cos(tilt);
                x = _x; y = _y; z = _z;
            }
        } else if (type === 'flower') {
            const rBase = 15;
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const petals = 5;
            const r = rBase + 5 * Math.sin(petals * u) * Math.sin(v);
            x = r * Math.sin(v) * Math.cos(u);
            y = r * Math.sin(v) * Math.sin(u);
            z = r * Math.cos(v) * 0.5;
        } else if (type === 'buddha') {
            const rand = Math.random();
            let r, theta, phi;
            if (rand < 0.4) { 
                r = 9 * Math.cbrt(Math.random());
                theta = Math.random() * Math.PI * 2;
                phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta) - 5;
                z = r * Math.cos(phi) * 0.8;
            } else if (rand < 0.6) { 
                r = 5 * Math.cbrt(Math.random());
                theta = Math.random() * Math.PI * 2;
                phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta) + 7;
                z = r * Math.cos(phi);
            } else { 
                r = 12 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                x = r * Math.cos(theta);
                z = r * Math.sin(theta);
                y = (Math.random() - 0.5) * 3 - 12;
            }
        } else if (type === 'fireworks') {
            const r = 40 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
        }

        newPositions[idx] = x;
        newPositions[idx + 1] = y;
        newPositions[idx + 2] = z;
    }
    
    targetPositions = newPositions;
    
    // ç¡®ä¿ shape-name å…ƒç´ å­˜åœ¨å¹¶æ›´æ–°
    const shapeNameElement = document.getElementById('shape-name');
    if (shapeNameElement) {
        // æŸ¥æ‰¾å½¢çŠ¶çš„ä¸­æ–‡åç§°
        let displayName = type.charAt(0).toUpperCase() + type.slice(1);
        switch (type) {
            case 'heart': displayName = 'å¿ƒå½¢'; break;
            case 'sphere': displayName = 'çƒä½“'; break;
            case 'saturn': displayName = 'åœŸæ˜Ÿ'; break;
            case 'flower': displayName = 'èŠ±å½¢'; break;
            case 'buddha': displayName = 'ä½›é™€'; break;
            case 'fireworks': displayName = 'çƒŸèŠ±'; break;
        }
        shapeNameElement.innerText = displayName;
    } else {
        console.error("UI Error: 'shape-name' element not found.");
    }
    
    applyCurrentColorPalette(); 
}

/**
 * åŠ¨ç”»ä¸æ¸²æŸ“å¾ªç¯ (ä¿æŒé«˜çµæ•åº¦ä¼˜åŒ–)
 */
function animate() {
    requestAnimationFrame(animate);

    const time = clock.getElapsedTime();
    const lerpFactor = 0.15; 

    // 1. æ—‹è½¬æ§åˆ¶ (ä»…åœ¨æœªé”å®šæ—¶)
    if (handInteraction.detected && !isRotationLocked) {
        const targetRotY = (handInteraction.centerX - 0.5) * 8.0; 
        const targetRotX = (handInteraction.centerY - 0.5) * 8.0; 
        
        particleSystem.rotation.y = THREE.MathUtils.lerp(particleSystem.rotation.y, targetRotY, lerpFactor);
        particleSystem.rotation.x = THREE.MathUtils.lerp(particleSystem.rotation.x, targetRotX, lerpFactor);
        
        const targetPosZ = (handInteraction.centerZ - 0.5) * 50; 
        particleSystem.position.z = THREE.MathUtils.lerp(particleSystem.position.z, targetPosZ, lerpFactor);

    } else if (!handInteraction.detected) {
        particleSystem.rotation.y += 0.002;
        particleSystem.rotation.x = THREE.MathUtils.lerp(particleSystem.rotation.x, 0, 0.05);
        particleSystem.position.z = THREE.MathUtils.lerp(particleSystem.position.z, 0, 0.05);
    }
    
    // ç¡®ä¿ lock-state å…ƒç´ å­˜åœ¨
    const lockStateElement = document.getElementById('lock-state');
    if (lockStateElement) {
        lockStateElement.innerText = isRotationLocked ? 'å·²é”å®š (OK é€€å‡º)' : 'æœªé”å®š (O ç¯è¿›å…¥)';
    }


    // 2. æ›´æ–°ç²’å­ä½ç½® (æ‰©æ•£/å‡èš) - ååº”å¼ºåº¦å¢å¼º
    const positions = particleSystem.geometry.attributes.position.array;
    const count = CONFIG.particleCount;

    const openness = handInteraction.openness;
    const lerpSpeed = 0.08; 
    const dispersionFactor = openness * 40; // å¢å¼ºæ‰©æ•£ç³»æ•°
    
    for (let i = 0; i < count; i++) {
        const idx = i * 3;
        
        let tx = targetPositions[idx];
        let ty = targetPositions[idx + 1];
        let tz = targetPositions[idx + 2];

        // æ‰©æ•£æ•ˆæœ: é™ä½æ¿€æ´»é˜ˆå€¼ 
        if (openness > 0.05) { 
            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.001;
            const dirX = tx / dist;
            const dirY = ty / dist;
            const dirZ = tz / dist;

            const pulse = Math.sin(time * 3 + dist * 0.1) * (openness * 2);
            
            tx += dirX * (dispersionFactor + pulse);
            ty += dirY * (dispersionFactor + pulse);
            tz += dirZ * (dispersionFactor + pulse);
        }

        positions[idx] += (tx - positions[idx]) * lerpSpeed;
        positions[idx + 1] += (ty - positions[idx + 1]) * lerpSpeed;
        positions[idx + 2] += (tz - positions[idx + 2]) * lerpSpeed;
    }

    particleSystem.geometry.attributes.position.needsUpdate = true;
    
    // 3. æ•´ä½“ç¼©æ”¾ 
    const targetScale = handInteraction.scale;
    particleSystem.scale.setScalar(THREE.MathUtils.lerp(particleSystem.scale.x, targetScale, 0.1));

    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * èƒŒæ™¯åˆ‡æ¢æ ¸å¿ƒåŠŸèƒ½
 */
function setBackgroundMode(mode) {
    backgroundMode = mode;
    updateBackground(mode);
}

function updateBackground(mode) {
    const videoContainer = document.getElementById('video-container');
    const imageBackground = document.getElementById('image-background');
    const body = document.body;
    const bgModeNameElement = document.getElementById('bg-mode-name');
    
    // éšè—æ‰€æœ‰èƒŒæ™¯å±‚
    videoContainer.style.display = 'none';
    imageBackground.style.display = 'none';
    imageBackground.style.backgroundImage = 'none';

    // è®¾ç½® Scene èƒŒæ™¯ (ä»…å½“çº¯é»‘æ¨¡å¼æ—¶, å¦åˆ™ Three.js ä¿æŒé€æ˜)
    if (renderer) {
        renderer.setClearColor(0x000000, 0); // é»˜è®¤é€æ˜
    }
    
    // åˆ‡æ¢æ¨¡å¼
    if (mode === 'camera') {
        videoContainer.style.display = 'block';
        body.style.backgroundColor = '#000000'; // ç¡®ä¿ body åº•éƒ¨æ˜¯é»‘çš„
        if (bgModeNameElement) bgModeNameElement.innerText = 'ğŸ¥ æ‘„åƒå¤´';
    } else if (mode === 'black') {
        body.style.backgroundColor = '#000000';
        // å¯é€‰: å¦‚æœå¸Œæœ› Three.js æ¸²æŸ“å™¨è‡ªå·±æ¸…ç©ºä¸ºé»‘è‰², å¯ä»¥è®¾ç½® clear alpha ä¸º 1
        if (renderer) renderer.setClearColor(0x000000, 1);
        if (bgModeNameElement) bgModeNameElement.innerText = 'âš« çº¯é»‘èƒŒæ™¯';
    } else if (mode === 'image') {
        imageBackground.style.display = 'block';
        body.style.backgroundColor = '#000000';
        if (bgModeNameElement) bgModeNameElement.innerText = 'ğŸ–¼ï¸ è‡ªå®šä¹‰å›¾ç‰‡';
    }
}

function handleImageUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const imageUrl = e.target.result;
            const imageBackground = document.getElementById('image-background');
            
            // è®¾ç½®èƒŒæ™¯å›¾ç‰‡
            imageBackground.style.backgroundImage = `url('${imageUrl}')`;
            
            // åˆ‡æ¢åˆ°å›¾ç‰‡èƒŒæ™¯æ¨¡å¼
            setBackgroundMode('image');
        };
        reader.readAsDataURL(file);
    }
}

/**
 * MediaPipe Hands é›†æˆ
 */
function initMediaPipe() {
    const videoElement = document.querySelector('.input_video');
    
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1, 
        minDetectionConfidence: 0.75, 
        minTrackingConfidence: 0.75
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    
    cameraUtils.start()
        .then(() => {
            const loadingMsg = document.getElementById('loading-msg');
            const overlayGuide = document.getElementById('overlay-guide');
            if (loadingMsg) loadingMsg.style.display = 'none';
            if (overlayGuide) {
                overlayGuide.style.opacity = '0';
                // ç¡®ä¿ç”¨æˆ·å¯ä»¥çœ‹åˆ° UI
                overlayGuide.style.pointerEvents = 'none'; 
            }
        })
        .catch(err => {
            console.error("[MediaPipe ERROR] æ— æ³•è®¿é—®æ‘„åƒå¤´, è¯·æ£€æŸ¥æƒé™ã€‚", err);
            const loadingMsg = document.getElementById('loading-msg');
            if (loadingMsg) loadingMsg.innerHTML = "<span class='text-red-400'>âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ã€‚</span>";
            // æ‘„åƒå¤´å¯åŠ¨å¤±è´¥æ—¶, é»˜è®¤åˆ‡æ¢åˆ°çº¯é»‘èƒŒæ™¯æ¨¡å¼
            setBackgroundMode('black');
        });
}

// è¾…åŠ©å‡½æ•°: è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„ 3D è·ç¦»
function distance(p1, p2) {
    return Math.sqrt(
        Math.pow(p1.x - p2.x, 2) + 
        Math.pow(p1.y - p2.y, 2) + 
        Math.pow(p1.z - p2.z, 2)
    );
}

// è¾…åŠ©å‡½æ•°: æ£€æŸ¥æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (åŸºäº Y åæ ‡ä¸æ‰‹è…•çš„ç›¸å¯¹ä½ç½®)
function isFingerStraight(hand, tipIdx, pipIdx) {
    return hand[tipIdx].y < hand[pipIdx].y; 
}

// è¾…åŠ©å‡½æ•°: æ£€æŸ¥æ˜¯å¦æ˜¯ V å­—æ‰‹åŠ¿ 
function checkVSign(hand) {
    const isIndexStraight = isFingerStraight(hand, 8, 7);
    const isMiddleStraight = isFingerStraight(hand, 12, 11);
    const isRingBent = hand[16].y > hand[15].y;
    const isPinkyBent = hand[20].y > hand[19].y;
    
    return isIndexStraight && isMiddleStraight && isRingBent && isPinkyBent;
}

// è¾…åŠ©å‡½æ•°: æ£€æŸ¥æ˜¯å¦æ˜¯ O ç¯æ‰‹åŠ¿ 
function checkOKSign(hand) {
    const pinchDist = distance(hand[4], hand[8]); 
    const isRingStraight = isFingerStraight(hand, 16, 15);
    const isMiddleStraight = isFingerStraight(hand, 12, 11);
    const isPinkyStraight = isFingerStraight(hand, 20, 19);
    
    return pinchDist < CONFIG.pinchThreshold * 1.5 && isRingStraight && isMiddleStraight && isPinkyStraight;
}

function onHandsResults(results) {
    const now = performance.now();
    const statusIndicator = document.getElementById('status-indicator');
    const gestureState = document.getElementById('gesture-state');

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handInteraction.detected = true;
        if (statusIndicator) statusIndicator.className = "w-4 h-4 rounded-full bg-green-500 shadow-[0_0_12px_lime]";
        
        const hand = results.multiHandLandmarks[0];
        const wristPoint = hand[0];
        
        handInteraction.centerX = hand[9].x; 
        handInteraction.centerY = hand[9].y;
        
        let normalizedZ = wristPoint.z;
        normalizedZ = Math.max(0.1, Math.min(0.9, normalizedZ));
        handInteraction.centerZ = normalizedZ;

        // --- é€»è¾‘1: V å­—æ‰‹åŠ¿ (é‡ç½®) ---
        const isCurrentVSign = checkVSign(hand);
        if (isCurrentVSign && !handInteraction.isVsign) {
            if (now - handInteraction.lastVsignTime > 1000) { 
                resetView();
                handInteraction.lastVsignTime = now;
            }
            handInteraction.isVsign = true;
        } else if (!isCurrentVSign) {
            handInteraction.isVsign = false;
        }

        // --- é€»è¾‘2: O ç¯æ‰‹åŠ¿ (æ—‹è½¬é”å®š) ---
        const isCurrentOKSign = checkOKSign(hand);
        if (isCurrentOKSign && !handInteraction.isOKsign) {
            if (now - handInteraction.lastOKsignTime > 1000) { 
                isRotationLocked = !isRotationLocked;
                handInteraction.lastOKsignTime = now;
            }
            handInteraction.isOKsign = true;
        } else if (!isCurrentOKSign) {
            handInteraction.isOKsign = false;
        }


        // --- é€»è¾‘3: ç²¾ç¡®æåˆæ‰‹åŠ¿ (é¢œè‰²/å½¢çŠ¶åˆ‡æ¢) ---
        const thumbTip = hand[4];
        
        // é£ŸæŒ‡æåˆ (é¢œè‰²)
        const indexPinchDist = distance(thumbTip, hand[8]); 
        if (indexPinchDist < CONFIG.pinchThreshold && !handInteraction.pinchIndex && !handInteraction.isOKsign) {
            if (now - handInteraction.lastPinchIndexTime > 500) { 
                changeColor(true);
                handInteraction.lastPinchIndexTime = now;
            }
            handInteraction.pinchIndex = true;
        } else if (indexPinchDist >= CONFIG.pinchThreshold) {
            handInteraction.pinchIndex = false;
        }

        // ä¸­æŒ‡æåˆ (å½¢çŠ¶)
        const middlePinchDist = distance(thumbTip, hand[12]); 
        if (middlePinchDist < CONFIG.pinchThreshold && !handInteraction.pinchMiddle && !handInteraction.isOKsign) {
            if (now - handInteraction.lastPinchMiddleTime > 500) { 
                setShape(true);
                handInteraction.lastPinchMiddleTime = now;
            }
            handInteraction.pinchMiddle = true;
        } else if (middlePinchDist >= CONFIG.pinchThreshold) {
            handInteraction.pinchMiddle = false;
        }


        // --- é€»è¾‘4: å•æ‰‹å¼ åˆç¨‹åº¦ (æ‰©æ•£/å‡èš) - ä¼˜åŒ–çµæ•åº¦ ---
        const wristToPalm = distance(hand[0], hand[9]); 
        const tipsDist = distance(hand[8], hand[20]); 
        
        let openRatio = tipsDist / (wristToPalm * 3.0); 
        openRatio = Math.max(0, Math.min(1, openRatio));
        handInteraction.openness = THREE.MathUtils.lerp(handInteraction.openness, openRatio, 0.2);


        // --- é€»è¾‘5: åŒæ‰‹æ§åˆ¶ç¼©æ”¾ ---
        if (results.multiHandLandmarks.length === 2) {
            const h1 = results.multiHandLandmarks[0][0]; 
            const h2 = results.multiHandLandmarks[1][0]; 
            const dist = distance(h1, h2);
            
            let scaleFactor = (dist - 0.2) * 4 + 0.5; 
            scaleFactor = Math.max(0.5, Math.min(4.0, scaleFactor));
            
            handInteraction.scale = scaleFactor;
            if (gestureState) gestureState.innerText = "åŒæ‰‹ç¼©æ”¾";
        } else {
            handInteraction.scale = 1.0; 
            
            // æ›´æ–°å•æ‰‹æ‰‹åŠ¿çŠ¶æ€æç¤º
            if (gestureState) {
                if (handInteraction.isVsign) {
                     gestureState.innerText = "âœŒï¸ V å­—æ‰‹åŠ¿ (å·²é‡ç½®)";
                } else if (handInteraction.isOKsign) {
                     gestureState.innerText = "ğŸ‘Œ O ç¯æ‰‹åŠ¿ (é”å®š/è§£é”)";
                } else if (handInteraction.pinchIndex) {
                     gestureState.innerText = "ğŸ‘‰+ğŸ¤ é¢œè‰²åˆ‡æ¢";
                } else if (handInteraction.pinchMiddle) {
                     gestureState.innerText = "ğŸ–•+ğŸ¤ å½¢çŠ¶åˆ‡æ¢";
                } else if (openRatio > 0.7) {
                     gestureState.innerText = "ğŸ–ï¸ æ‰‹æŒå¼ å¼€ (æ‰©æ•£)";
                } else if (openRatio < 0.3) {
                     gestureState.innerText = "âœŠ æ¡æ‹³ (å‡èš)";
                } else {
                     gestureState.innerText = "â†”ï¸ ç§»åŠ¨æ‰‹æŒ (æ—‹è½¬/æ·±åº¦)";
                }
            }
        }
        
    } else {
        handInteraction.detected = false;
        handInteraction.openness = THREE.MathUtils.lerp(handInteraction.openness, 0, 0.1); 
        handInteraction.scale = THREE.MathUtils.lerp(handInteraction.scale, 1, 0.1);
        
        if (statusIndicator) statusIndicator.className = "w-4 h-4 rounded-full bg-red-500 shadow-[0_0_12px_red]";
        if (gestureState) gestureState.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
    }
}

/**
 * UI/Gesture äº¤äº’åŠŸèƒ½
 */
function setShape(next = false) {
    if (next) {
        currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
    }
    generateShape(SHAPES[currentShapeIndex]);
}

// æ–°å¢åŠŸèƒ½: é€šè¿‡åç§°è®¾ç½®å½¢çŠ¶, å¯¹åº” HTML æŒ‰é’®
function setShapeByName(name) {
    const index = SHAPES.indexOf(name);
    if (index !== -1) {
        currentShapeIndex = index;
        generateShape(SHAPES[currentShapeIndex]);
    } else {
        console.error(`Shape '${name}' not found in SHAPES array.`);
    }
}

function changeColor(next = false) {
    if (next) {
        currentColorIndex = (currentColorIndex + 1) % COLOR_PALETTES.length;
    }
    applyCurrentColorPalette();
}

function resetView() {
    particleSystem.rotation.x = THREE.MathUtils.lerp(particleSystem.rotation.x, 0, 1);
    particleSystem.rotation.y = THREE.MathUtils.lerp(particleSystem.rotation.y, 0, 1);
    particleSystem.position.z = THREE.MathUtils.lerp(particleSystem.position.z, 0, 1);
    handInteraction.scale = 1.0; 
}


// å¯åŠ¨ç¨‹åº
initThree();
// 1ç§’ååˆå§‹åŒ– MediaPipe, é»˜è®¤å°è¯•å¯åŠ¨æ‘„åƒå¤´
setTimeout(initMediaPipe, 1000);

</script>
</body>
</html>